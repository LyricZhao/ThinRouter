# ifndef __UTILITY_H__
# define __UTILITY_H__

# define CATCH(type, addr)  (*((type *) (addr)))
# define WRITE(type, addr, data)  (*((type *)addr)) = (data)

typedef unsigned int u32;

# define DISP_CLEAR_SCREEN      0x00
# define DISP_NEW_LINE          0x0a // '\n'
# define DISP_BACKSPACE         0x7f // backspace
# define DISP_ENTER             0x01 // enter

# define true 1
# define false 0

# define MAX_LENGTH 1024

# include "address.h"

static u32 compare_str(char *a, char *b) {
    for (; (*a) && (*b); ++ a, ++ b) {
        if ((*a) != (*b)) {
            return 0;
        }
    }
    return (*a) == (*b);
}

// TODO: 有时间改成中断
static void putc(u32 data) {
    volatile u32 stat;
    while (true) {
        stat = CATCH(u32, ADDR_UART_STATUS);
        if (stat & 1) { // 可写
            WRITE(int, ADDR_UART_DATA, data);
            break;
        }
    }
}

// 打印一个 0-F 的字符
static void putHexDigit(u32 digit) {
    if (digit < 10) {
        putc(digit + 48);
    } else {
        putc(digit + 55);
    }
}

static void printHex(u32 hex) {
    for (int i = 28; i >= 0; i -= 4) {
        putHexDigit((hex >> i) & 0xf);
    }
}

static void printDecByte(u32 dec) {
  static u32 _lookup[256] = {
    0x0,   0x1,   0x2,   0x3,   0x4,   0x5,   0x6,   0x7,   0x8,   0x9,
    0x10,  0x11,  0x12,  0x13,  0x14,  0x15,  0x16,  0x17,  0x18,  0x19,
    0x20,  0x21,  0x22,  0x23,  0x24,  0x25,  0x26,  0x27,  0x28,  0x29,
    0x30,  0x31,  0x32,  0x33,  0x34,  0x35,  0x36,  0x37,  0x38,  0x39,
    0x40,  0x41,  0x42,  0x43,  0x44,  0x45,  0x46,  0x47,  0x48,  0x49,
    0x50,  0x51,  0x52,  0x53,  0x54,  0x55,  0x56,  0x57,  0x58,  0x59,
    0x60,  0x61,  0x62,  0x63,  0x64,  0x65,  0x66,  0x67,  0x68,  0x69,
    0x70,  0x71,  0x72,  0x73,  0x74,  0x75,  0x76,  0x77,  0x78,  0x79,
    0x80,  0x81,  0x82,  0x83,  0x84,  0x85,  0x86,  0x87,  0x88,  0x89,
    0x90,  0x91,  0x92,  0x93,  0x94,  0x95,  0x96,  0x97,  0x98,  0x99,
    0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109,
    0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119,
    0x120, 0x121, 0x122, 0x123, 0x124, 0x125, 0x126, 0x127, 0x128, 0x129,
    0x130, 0x131, 0x132, 0x133, 0x134, 0x135, 0x136, 0x137, 0x138, 0x139,
    0x140, 0x141, 0x142, 0x143, 0x144, 0x145, 0x146, 0x147, 0x148, 0x149,
    0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157, 0x158, 0x159,
    0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0x168, 0x169,
    0x170, 0x171, 0x172, 0x173, 0x174, 0x175, 0x176, 0x177, 0x178, 0x179,
    0x180, 0x181, 0x182, 0x183, 0x184, 0x185, 0x186, 0x187, 0x188, 0x189,
    0x190, 0x191, 0x192, 0x193, 0x194, 0x195, 0x196, 0x197, 0x198, 0x199,
    0x200, 0x201, 0x202, 0x203, 0x204, 0x205, 0x206, 0x207, 0x208, 0x209,
    0x210, 0x211, 0x212, 0x213, 0x214, 0x215, 0x216, 0x217, 0x218, 0x219,
    0x220, 0x221, 0x222, 0x223, 0x224, 0x225, 0x226, 0x227, 0x228, 0x229,
    0x230, 0x231, 0x232, 0x233, 0x234, 0x235, 0x236, 0x237, 0x238, 0x239,
    0x240, 0x241, 0x242, 0x243, 0x244, 0x245, 0x246, 0x247, 0x248, 0x249,
    0x250, 0x251, 0x252, 0x253, 0x254, 0x255};
  if (dec == 0) {
      putc('0');
      return;
  }
  u32 value = _lookup[dec & 0xffu];
  u32 start = 0;
  for (int i = 8; i >= 0; i -= 4) {
      u32 digit = (value >> i) & 0xfu;
      if (digit) {
          start = 1;
      }
      if (start) {
          putc('0' + digit);
      }
  }
}

// 同时向串口和屏幕发送（这里串口和屏幕的地址写在了一起）为了速度后面可以拆开
static void print(char *str) {
    for (;(*str) != 0; ++ str) {
        putc(*str);
    }
}

static void puts(char *str) {
    for (;(*str) != 0; ++ str) {
        putc(*str);
    }
    putc('\n');
}

static char read() {
    volatile u32 stat;
    while (true) {
        stat = CATCH(u32, ADDR_UART_STATUS);
        if (stat & 2) { // 有数据
            return CATCH(u32, ADDR_UART_DATA) & 0xff;
        }
    }
    return 0;
}

# endif